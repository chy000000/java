# 计算机网络

## 网络层

网络层只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。

IP 在 TCP/IP 参考模型中处于第三层，也就是**网络层**。

网络层的主要作用是：**实现主机与主机之间的通信，也叫点对点（end to end）通信。**

> 网络层与数据链路层有什么关系呢？

其实很容易区分，在上面我们知道 IP 的作用是主机之间通信中的，而 **MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。**

举个生活的栗子，小林要去一个很远的地方旅行，制定了一个行程表，其间需先后乘坐飞机、地铁、公交车才能抵达目的地，为此小林需要买飞机票，地铁票等。

飞机票和地铁票都是去往特定的地点的，每张票只能够在某一限定区间内移动，此处的「区间内」就如同通信网络中数据链路。

在区间内移动相当于数据链路层，充当区间内两个节点传输的功能，区间内的出发点好比源 MAC 地址，目标地点好比目的 MAC 地址。

整个旅游行程表就相当于网络层，充当远程定位的功能，行程的开始好比源 IP，行程的终点好比目的 IP 地址。

![image-20210129105510341](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210129105510341.png)

如果小林只有行程表而没有车票，就无法搭乘交通工具到达目的地。相反，如果除了车票而没有行程表，恐怕也很难到达目的地。因为小林不知道该坐什么车，也不知道该在哪里换乘。

因此，只有两者兼备，既有某个区间的车票又有整个旅行的行程表，才能保证到达目的地。与此类似，**计算机网络中也需要「数据链路层」和「网络层」这个分层才能实现向最终目标地址的通信。**

还有重要一点，旅行途中我们虽然不断变化了交通工具，但是旅行行程的起始地址和目的地址始终都没变。其实，在网络中数据包传输中也是如此，**源IP地址和目标IP地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化。**

### IP地址

在 TCP/IP 网络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则无法实现正常的通信。

IP 地址（IPv4 地址）由 `32` 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。

![image-20210129113733637](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210129113733637.png)

那么，IP 地址最大值也就是 

![image-20210129113748947](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210129113748947.png)

> 可能有的小伙伴提出了疑问，现在不仅电脑配了 IP， 手机、IPad 等电子设备都配了 IP 呀，照理来说肯定会超过 43 亿啦，那是怎么能够支持这么多 IP 的呢？

因为会根据一种可以更换 IP 地址的技术 `NAT`，使得可连接计算机数超过 43 亿台。`NAT` 技术后续会进一步讨论和说明。

#### IP地址的分类

IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。

![image-20210129113853514](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210129113853514.png)、

上图中黄色部是分类号，用以区分 IP 地址类别。

> 什么是 A、B、C 类地址？

A、B、C类地址都是单播地址（一对一通信），是最常用的。

对于 A、B、C 类主要分为两个部分，分别是**网络号和主机号**。

A、B、C类地址的网络字段分别是1个、2个、3个字节长（注：单位是字节），而在网络号字段的最前面有1~3位的类别位，其数值分别规定位0，10和110。

A、B、C 分类对应的IP地址的指派范围：

| 网络类别 | 最大可指派的网络数 | 第一个可指派的网络号 | 最后一个可指派的网络号 | 每个网络中最大主机数 |
| -------- | ------------------ | -------------------- | ---------------------- | -------------------- |
| A        | 126 (2^7-2)        | 1                    | 126                    | 16777214             |
| B        | 16383 (2^14-1)     | 128.1                | 191.255                | 65534                |
| C        | 2097151 (2^21-1)   | 192.0.1              | 223.255.255            | 254                  |

> A、B、C 分类地址最大网络数是如何计算的呢？

* A类IP地址中的全0表示为本网络，全1（127，即01111111）保留作为本地软件环回测试本机的进程之间的通信，目的地址位环回地址的IP数据报永远不会出现在任何网络上。
* B类地址的网络号有2个字节，但前面两位（10）已经固定了，只剩下14位可以进行分配。因为前14位不可能取到全0或全1的网络号，因此这里的网络数不存在减2的问题。但实际上B类网络地址128.0.0.0是不指派的，可以指派的B类最小网络地址是128.1.0.0，因此B类地址可知拍的网络数位2^14-1。
* B类地址的网络号有3个字节，但前面三位（110）已经固定了，只剩下21位可以进行分配。因为前21位不可能取到全0或全1的网络号，因此这里的网络数不存在减2的问题。C类网络地址192.0.0.0也是不指派的，可以指派的C类最小网络地址是192.0.1.0，因此B类地址可知拍的网络数位2^21-1。

> A、B、C 分类地址最大主机个数是如何计算的呢？

![image-20210129114731534](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210129114731534.png)

为什么要减 2 呢？

因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。

![image-20210129114757179](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210129114757179.png)

- 主机号全为 1 指定某个网络下的所有主机，用于广播
- 主机号全为 0 指定某个网络

因此，在分配过程中，应该去掉这两种情况。

> 广播地址用于什么？

广播地址用于在**同一个链路中相互连接的主机之间发送数据包**。

学校班级中就有广播的例子，在准备上课的时候，通常班长会喊：“上课， 全体起立！”，班里的同学听到这句话是不是全部都站起来了？这个句话就有广播的含义。

当主机号全为 1 时，就表示该网络的广播地址。例如把 `172.20.0.0/16` 用二进制表示如下：

10101100.00010100.00000000.00000000

将这个地址的**主机部分全部改为 1**，则形成广播地址：

10101100.00010100.**11111111.11111111**

再将这个地址用十进制表示，则为 `172.20.255.255`。

广播地址可以分为本地广播和直接广播两种。

- **在本网络内广播的叫做本地广播**。例如网络地址为 192.168.0.0/24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。
- **在不同网络之间的广播叫做直接广播**。例如网络地址为 192.168.0.0/24 的主机向 192.168.1.255/24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给192.168.1.0/24，从而使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发）。

![image-20210129115441770](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210129115441770.png)



> 什么是 D、E 类地址？

D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于**多播**，E 类是预留的分类，暂时未使用。

![image-20210129115148522](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210129115148522.png)

> 多播地址用于什么？

多播用于**将包发送给特定组内的所有主机。**

还是举班级的栗子，老师说：“最后一排的同学，上来做这道数学题。”，老师是指定的是最后一排的同学，也就是多播的含义了。

由于广播无法穿透路由，若想给其他网段发送同样的包，就可以使用可以穿透路由的多播（组播）。

![image-20210129115541499](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210129115541499.png)

多播使用的 D 类地址，其前四位是 `1110` 就表示是多播地址，而剩下的 28 位是多播的组编号。

从 224.0.0.0 ~ 239.255.255.255 都是多播的可用范围，其划分为以下三类：

- 224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能局域网中，路由器是不会进行转发的
- 224.0.1.0 ~ 238.255.255.255  为用户可用的组播地址，可以用于 Internet 上
- 239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部网在内部使用，仅在特定的本地范围内有效

> IP 分类的优点

不管是路由器还是主机解析到一个 IP 地址时候，我们判断其 IP 地址的首位是否为 0，为 0 则为 A 类地址，那么就能很快的找出网络地址和主机地址。

其余分类判断方式参考如下图:

![image-20210129115827056](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210129115827056.png)

所以，这种分类地址的优点就是**简单明了、选路（基于网络地址）简单**。

> IP 分类的缺点

*缺点一*

**同一网络下没有地址层次**，比如一个公司里用了 B 类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就**缺少地址的灵活性**。

*缺点二*

A、B、C类有个尴尬处境，就是**不能很好的与现实网络匹配**。

- C 类地址能包含的最大主机数量实在太少了，只有 254 个，估计一个网吧都不够用。
- 而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。

这两个缺点，都可以在 `CIDR` 无分类地址解决。

> 在封装成MAC帧时，主机是如何知道应当停入什么样的目的地址的MAC地址？

已经知道了一个机器的IP地址，需要找出其相应的硬件地址，地址解析协议ARP就是解决这样的问题。

每台主机都会有一个ARP高速缓存，里面存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新。

如果查不到，则作如下步骤：

1. ARP进程在本局域网上广播发送一个ARP请求分组，请求分组的主要内容是：我的IP地址是……，硬件地址是……，我想知道IP地址为……主机的硬件地址。
2. 在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组。
3. 如果主机B的IP地址与ARP请求分组中查询的IP地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组，同时在这个ARP相应分组中写入自己的硬件地址。其他主机的IP地址都与这个ARP请求分组中要查询的IP地址不一致，因此都不理睬这个ARP求情分组。主机B响应的主要内容是：我的IP地址是……，我的硬件地址是……。ARP请求分组是广播发送的，ARP响应分组时普通的单播。
4. 主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。此时主机B在收到请求分组后，也会将A的IP地址写道自己的ARP高速缓存的映射中。

> ip地址分为4类网络，层次分明，但是不均匀，浪费过多，如何解决？

1. 子网划分，子网掩码
2. CIDR

> 如何提高IP数据包和提高交付成功的机会？

使用网际控制报文协议ICMP。ICMP语序主机或路由器报告差错情况和提供有关异常情况的报告。

#### 互联网的路由选择协议

1. 内部网关协议IGP

   * RIP：基于距离向量的路由选择协议

     仅和相邻路由器交换信息

     路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由器

     按固定的时间间隔交换路由信息

   * OSPF：基于链路状态协议

     向本自治系统中所有路由器发送信息，洪泛法。

     发送的信息就是与本路由器相邻的所有路由器的链路状态

     只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息

2. 外部网关协议BGP

#### IPv6

#### IP多播

IGMP网际组管理协议和多播路由选择协议。

#### IP协议相关技术

1. DNS

   > 域名的层级关系

   DNS 中的域名都是用**句点**来分隔的，比如 `www.server.com`，这里的句点代表了不同层次之间的**界限**。

   在域名中，**越靠右**的位置表示其层级**越高**。

   毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。

   根域是在最顶层，它的下一层就是 com 顶级域，再下面是 server.com。

   所以域名的层级关系类似一个树状结构：

   - 根 DNS 服务器
   - 顶级域 DNS 服务器（com）
   - 权威 DNS 服务器（server.com）

   ![image-20210201123229424](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210201123229424.png)

   > 域名解析的工作流程

   浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 `hosts`，如果还是没有，就会 DNS 服务器进行查询，查询的过程如下：

   1. 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
   2. 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
   3. 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”
   4. 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com  的 IP 地址吗？”
   5. 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
   6. 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
   7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
   8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

   ![image-20210201123314746](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210201123314746.png)

2. ARP

   在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的 MAC 地址。

   ![image-20210201123345883](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210201123345883.png)

3. DHCP

   DHCP 在生活中我们是很常见的了，我们的电脑通常都是通过 DHCP 动态获取 IP 地址，大大省去了配 IP 信息繁琐的过程。

   接下来，我们来看看我们的电脑是如何通过 4 个步骤的过程，获取到 IP 的。

   ![image-20210201123737633](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210201123737633.png)

   DHCP 交互的 4 个步骤：

   - 客户端首先发起 **DHCP 发现报文（DHCP DISCOVER）** 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP **广播**通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。
   - DHCP 服务器收到 DHCP 发现报文时，用 **DHCP 提供报文（DHCP OFFER）** 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 **IP 地址租用期**。
   - 客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 **DHCP 请求报文（DHCP REQUEST**进行响应，回显配置的参数。
   - 最后，服务端用 **DHCP ACK 报文**对 DHCP 请求报文进行响应，应答所要求的参数。

   一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。

   如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：

   - 服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。
   - 服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。

   可以发现，DHCP 交互中，**全程都是使用 UDP 广播通信**。

   > 咦，用的是广播，那如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个 DHCP 服务器？

   为了解决这一问题，就出现了 **DHCP 中继代理**。

   有了 DHCP 中继代理以后，**对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。**

   ![image-20210201123859271](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210201123859271.png)

   - DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以**单播**的形式发给 DHCP 服务器。
   - 服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包转发给 DHCP 客户端 。

   4. NAT

      IPv4 的地址是非常紧缺的，在前面我们也提到可以通过无分类地址来减缓 IPv4 地址耗尽的速度，但是互联网的用户增速是非常惊人的，所以 IPv4 地址依然有被耗尽的危险。

      于是，提出了一个种**网络地址转换 NAT** 的方法，再次缓解了 IPv4 地址耗尽的问题。

      > 那不是 N 个 私有 IP 地址，你就要 N 个公有 IP 地址？这怎么就缓解了 IPv4 地址耗尽的问题？这不瞎扯吗？

      确实是，普通的 NAT 转换没什么意义。

      由于绝大多数的网络应用都是使用传输层协议 TCP 或 UDP 来传输数据的。

      因此，可以把 IP 地址 + 端口号一起进行转换。

      这样，就用一个全球 IP 地址就可以了，这种转换技术就叫**网络地址与端口转换 NAPT。**

      **两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。**

      于是，生成一个 NAPT 路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端 A、B 能同时与服务器之间进行通信。

      这种转换表在 NAT 路由器上自动生成。例如，在 TCP 的情况下，建立 TCP 连接首次握手时的 SYN 包一经发出，就会生成这个表。而后又随着收到关闭连接时发出 FIN 包的确认应答从表中被删除。

      > NAT 那么牛逼，难道就没缺点了吗？

      由于 NAT/NAPT 都依赖于自己的转换表，因此会有以下的问题：

      - 外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。
      - 转换表的生产与转换操作都会产生性能开销。
      - 通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。

      > 如何解决 NAT 潜在的问题呢？

      解决的方法主要两种方法。

      *第一种就是改用 IPv6*

      *第二种 NAT 穿透技术*

      NAT 穿越技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目，注意这些都是 NAT设备后的应用程序自动完成的。

      也就是说，在 NAT 穿越技术中，NAT 设备后的应用程序处于主动地位，它已经明确地知道 NAT 设备要修改它外发的数据包，于是它主动配合 NAT 设备的操作，主动地建立好映射，这样就不像以前由 NAT 设备来建立映射了。

      说人话，就是客户端主动从 NAT 设备获取公有 IP 地址，然后自己建立端口映射条目，然后用这个条目对外通信，就不需要 NAT 设备来进行转换了。

   5. ICMP **互联网控制报文协议**

      `ICMP` 主要的功能包括：**确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。**

      在 `IP` 通信中如果某个 `IP` 包因为某种原因未能达到目标地址，那么这个具体的原因将**由 ICMP 负责通知**。

      ![image-20210201124309012](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210201124309012.png)

      ICMP 大致可以分为两大类：

      - 一类是用于诊断的查询消息，也就是「**查询报文类型**」
      - 另一类是通知出错原因的错误消息，也就是「**差错报文类型**」

      ![image-20210201124329248](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210201124329248.png)

   6. IGMP

   

## 运输层

运输层为应用进程之间提供端到端的逻辑通信，运输层需要对收到的报文进行差错检测。

| 应用           | 应用层协议               | 运输层协议 |
| -------------- | ------------------------ | ---------- |
| 名字转换       | DNS（域名系统）          | UDP        |
| 文件传送       | TFTP（简单文件传送协议） | UDP        |
| 路由选择协议   | RIP（路由信息协议）      | UDP        |
| IP地址配置     | DHCP（动态主机配置协议） | UDP        |
| 网络管理       | SNMP（简单网络管理协议） | UDP        |
| 远程文件服务器 | NFS（网络文件系统）      | UDP        |
| IP电话         | 专用协议                 | UDP        |
| 流式多媒体通信 | 专用协议                 | UDP        |
| 多播           | IGMP（网际组管理协议）   | UDP        |
| 电子邮件       | SMTP（简单邮件传送协议） | TCP        |
| 远程终端接入   | TELNET（远程终端协议）   | TCP        |
| 万维网         | HTTP（超文本传送协议）   | TCP        |
| 文件传送       | FTP（文件传送协议）      | TCP        |

| 应用程序   | FTP  | TELNET | SMTP | DNS  | TFTP | HTTP | SNMP | SNMP（trap） | HTTPS |
| ---------- | ---- | ------ | ---- | ---- | ---- | ---- | ---- | ------------ | ----- |
| 熟知端口号 | 21   | 23     | 25   | 53   | 69   | 80   | 161  | 162          | 443   |

两类端口号：

* 熟知端口号或系统端口号
* 登记端口号

### UDP

1. 无连接的
2. 尽最大努力交付
3. 面向报文的
4. 没有拥塞控制
5. 支持一对一、一对多、多对一、多对多的交互通信
6. 首部开销小：4个字段，源端口，目的端口，长度，检验和（需要设置伪首部）

### TCP

1. 面向连接的运输层协议
2. 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的
3. TCP提供可靠交付服务
4. TCP提供全双工通信
5. 面向字节流

> 什么是套接字？

TCP连接的两个端点为套接字，是IP+端口号，表示为IP地址：端口号（192.3.4.5:80）

> 如何提供可靠交付服务

1. 停止等待协议
2. 连续ARQ（自动重传请求）协议和滑动窗口协议

> 零窗口可能出现的问题，即B向A发送零窗口的报文不久后，B的缓存又有一些存储空间，于是B向A发送了一个窗口不为0的报文，但是这个报文丢失了，A则一直等待B发送的非0窗口通知，B一直等待A发送的数据，造成死锁

TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就开启持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段，仅携带1字节的数据，而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不为零，那么死锁的僵局就打破了。

#### TCP流量控制

发送方的发送窗口不能超过接收方给出的接收窗口的数值。

#### TCP拥塞控制

> 拥塞控制和流量控制的区别

拥塞控制防止过多的数据注入到网络中，这样可以使网络中的路由器或者链路不致过载。

流量控制要做的是抑制发送端发送数据的速率，以便使接收端来得及接受。

TCP拥塞控制的算法有四种：慢开始，拥塞避免，快重传，快恢复。

主动队列管理AQM，解决全局同步问题，就是当路由器的队列慢时，会造成所有TCP连接进入慢开始状态，这样通信量则骤降。主动队列管理则是设定一个值，不在队列达到最大值时对传来的帧进行某一概率抛弃。

#### TCP连接管理

1. TCP连接建立（三次握手）

   ![image-20210202212126578](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210202212126578.png)

   > 为什么需要三次握手，A最后还要发送一次确认请求呢？

   防止已失效的连接请求报文段突然传送到了B

   *原因一：避免历史连接*

   我们来看看 RFC 793 指出的 TCP 连接使用三次握手的**首要原因**：

   *The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.*

   简单来说，三次握手的**首要原因是为了防止旧的重复连接初始化造成混乱。**

   网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，反而它很骚，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下 TCP 三次握手是如何避免的呢？

   ![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS8436nKau10lAsztRqbyhjC1C1GRcsEz04icZmomMjwcxgeGn97BnKUoxibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：

   - 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；
   - 那么此时服务端就会回一个 `SYN + ACK` 报文给客户端；
   - 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 `RST` 报文给服务端，表示中止这一次连接。

   如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：

   - 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 `RST` 报文，以此中止历史连接；
   - 如果不是历史连接，则第三次发送的报文是 `ACK` 报文，通信双方就会成功建立连接；

   所以， TCP 使用三次握手建立连接的最主要原因是**防止历史连接初始化了连接。**

   *原因二：同步双方初始序列号*

   *原因三：避免资源浪费*

   > SYN 超时了怎么处理？

   也就是 client 发送 SYN 至 server 然后就挂了，此时 server 发送 SYN+ACK 就一直得不到回复，怎么办？

   我脑海中一想到的就是重试，但是不能连续快速重试多次，你想一下，假设 client 掉线了，你总得给它点时间恢复吧，所以呢需要**慢慢重试，阶梯性重试**。

   在 Linux 中就是默认重试 5 次，并且就是阶梯性的重试，间隔就是1s、2s、4s、8s、16s，再第五次发出之后还得等 32s 才能知道这次重试的结果，所以说总共等63s 才能断开连接。

   > SYN 攻击

   我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的 SYN 接收队列（未连接队列）**，使得服务器不能为正常用户服务。

   *避免 SYN 攻击方式一*

   其中一种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。

   - 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：

   ```
   net.core.netdev_max_backlog
   ```

   

   - SYN_RCVD 状态连接的最大个数：

   ```
   net.ipv4.tcp_max_syn_backlog
   ```

   

   - 超出处理能时，对新的 SYN 直接回 RST，丢弃连接：

   ```
   net.ipv4.tcp_abort_on_overflow
   ```

2. TCP连接释放（四次挥手）

   ![image-20210202212159019](C:\Users\chy\Desktop\研究生相关信息\学习\计算机网络\img\image-20210202212159019.png)

   > 为什么A在TIME-WAIT状态必须等待2MSL的时间呢

   1. 保证A发送的最后一个ACK保温能够到达B。如果这个ACK保温丢失，B会超时重传这个FIN+ACK报文，A在2MSL时间内能收到这个重传报文。
   2. 防止已失效的连接请求报文。A在发送完最后一个ACK报文后，在经过2MSL事件后，就可以使本连接持续的时间内所产生的所有保温都从网络消失。

## 应用层

### DNS

递归查询和迭代查询

### HTTP

HTTP/1.1版本是最流行的版本，可以持久连接，TCP连接默认不关闭，可以被多个请求复用，只有在一段时间内，没有请求，就可以自动关闭。

请求报文有三部分：请求行，首部行，实体主体

请求行：

方法（get），URL，版本（HTTP/1.1）

响应报文有三部分：状态行，首部行，实体主体

状态行：

版本，状态码，短语

> HTTP状态码

HTTP状态码是用来干什么的呢？它的重要作用是Web服务器用来告诉客户端，当前的网页请求发生什么事情了，或者是当前web服务器端的响应状态，**HTTP状态码是服务器端返回给客户端的。**

**状态码：**

**有200,301,302,304,404,500,403。**

我们最常见的状态码为200，状态码200表示服务器响应成功，服务器找到了客户端请求的内容，并将内容发送给了客户端。

我们程序员有时候也常见的500，状态码500表示程序错误，就是说请求的网页程序本身就报错了。

现在的浏览器会对状态码500做出一定的处理，所以在一般情况下会返回一个定制的错误页面。

状态码404表示服务器上没有该资源，或者说是服务器上没有找到客户端请求的资源，是最常见的请求错误码。

状态码302表示临时跳转。

2xx:

200为请求已经成功，202为服务器已经接受请求，但尚未处理，204为服务器成功处理了请求，但不需要返回如何实体内容。

304状态码，被请求的资源内容没有发生更改。

400为包含语法错误，无法被服务器解析，403为服务器已经接收请求，但是被拒绝执行，404请求失败。

500为服务器内部错误，无法处理请求，502为作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效响应，504为作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应

200 OK 

请求被正确处理 

302 Found 

所请求的资源已暂时更改.通常会重定向到另一个 URL 

404 Not Found 

所请求的资源无法找到 

500 Internal Server Error 

服务器出现一般性错误 

更多状态码：

```
https://www.runoob.com/http/http-status-codes.html
```

*1xx*

`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

*2xx*

`2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。

「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。

「**206 Partial Content**」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

*3xx*

`3xx` 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。

「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。

「**302 Moved Permanently**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

*4xx*

`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。

「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。

「**404 Not Found**」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

*5xx*

`5xx` 类状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。

「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。

「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。

「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。

「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。

##### HTTP 特性



