---
typora-root-url: img
---

# 设计模式

## 六大原则

1. 开闭原则 (Open Close Principle)

   开闭原则的意思是：**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。

2. 里氏代换原则 (Liskov Subsitution Principle)

   里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。

3. 依赖倒转原则 (Dependence Inversion Principle)

   这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

4. 接口隔离原则 (Interface Segregation Principle)

   使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。

5. 迪米特法则，又称最少知道原则 (Demeter Principle)

   一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

6. 合成复用原则 (Composite Reuse Principle)

   尽量使用合成/聚合的方式，而不是使用继承。

## 单例模式

![image-20210110174839612](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210110174839612.png)

1. 懒汉模式

   ```java
   //懒汉模式
   class LazySingleton {
   
       private static LazySingleton instance;
   
       private LazySingleton() {
   
       }
   
       public static LazySingleton getInstance() {
           if (instance==null) {
               instance = new LazySingleton();
           }
           return instance;
       }
   }
   ```

   使用上段代码，如果不进行加锁，会在使用多线程时可能会多次实例化。

   ```java
   class LazySingleton {
   
       private volatile static LazySingleton instance;
   
       private LazySingleton() {
   
       }
   
       public static LazySingleton getInstance() {
           if (instance==null) {
               synchronized(LazySingleton.class) {
                   if (instance==null) {
                       instance = new LazySingleton();
                   }
               }
           }
           return instance;
       }
   }
   ```

   将加锁推迟到实例化位置，即如果还未实例，则加锁进行实例。加锁后应该再判断该单例是否实例化，如果不加判断，则在多线程时还会重复实例化。

   即懒汉模式需要双重check。

   在使用双重加锁后，还会出现问题，即指令重排，因此会在未赋值时，另一个线程就会调用这个实例，造成空指针错误。解决这个问题可以加入`voliatile`关键字，即不进行指令重排，因此不会产生错误。

2. 饿汉模式

   ```java
   public class HungrySingleton {
   
       private static HungrySingleton instance = new HungrySingleton();
   
       private HungrySingleton() {
            if (instance!=null) {
               throw new RuntimeException("单例不允许多个实例");
           }
       }
   
       public static HungrySingleton getInstance() {
           return instance;
       }
   }
   ```

   只有真正主动使用对应的类时，才会出发初始化，如直接进行new操作，访问静态属性、访问静态方法，用反射访问类，初始化一个类的子类等。

   在这种模式下，只要触发类加载，就会进行单例实例化。

   但是在使用反射时，可以设置构造函数可访问，如果不加if判断，则会产生多个实例。

3. 内部类模式

   ```java
   public class InnerClassSingleton {
   
       private static class SingletongHolder {
           private static InnerClassSingleton instance = new InnerClassSingleton();
       }
       
       private InnerClassSingleton() {
   
       }
       
       public static InnerClassSingleton getInstance() {
           return SingletongHolder.instance;
       }
   
   }
   ```

   只有在使用单例时才会对单例实例化。

4. 反序列化

   在使用序列化输出当前单例到磁盘上，在之后新的程序中初始化单例后，在读取序列化的单例，会破坏单例的单一性。可以添加`readResolve`方法来防止多个单例，此时会出现serialVersionUID不一致而抛出异常，因此需要申明serialVersionUID。

   ```java
   public class HungrySingleton implements Serializable {
   
       private final long serialVersionUID = -214092149;
   
       private static HungrySingleton instance = new HungrySingleton();
   
       private HungrySingleton() {
           if (instance!=null) {
              throw new RuntimeException("单例不允许多个实例");
           }
       }
   
       public static HungrySingleton getInstance() {
           return instance;
       }
   
       Object readResolve() throws ObjectStreamException {
           return getInstance();
       }
   }
   ```




## 工厂方法模式

![image-20210113195253260](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210113195253260.png)

```java
public class FactoryMethod {
    public static void main(String[] args) {
        Factory application = new ConcreteProductA();
        Product product = application.getObject();
        product.method();
        application = new ConcreteProductA1();
        product = application.getObject();
        product.method();
    }
}

interface Product {
    public void method();
}

class ProductA implements Product {

    public void method() {
        System.out.println("ProductA.method.");;
    }
}

class ProductA1 implements Product {

    public void method() {
        System.out.println("ProductA1.method.");;
    }
}

abstract class Factory {
    abstract Product createProduct();

    public Product getObject() {
        Product product = createProduct();
        return product;
    }
}

class ConcreteProductA extends Factory {

    Product createProduct() {
        return new ProductA();
    }
}

class ConcreteProductA1 extends Factory {

    Product createProduct() {
        return new ProductA1();
    }
}
```

开闭原则，之后添加新的product类别时，只需要加入新的类继承Factory即可，而不需要改动原有代码。将实例化延迟到子类。



## 抽象工厂模式

![image-20210113202153607](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210113202153607.png)

```java
public class AbstractFactory {
    public static void main(String[] args) {
        DatabaseUtils databaseUtils = new MysqlUitls();
        IConnection connection = databaseUtils.getConnection();
        connection.connect();
        ICommand command = databaseUtils.getCommand();
        command.command();
        databaseUtils = new OracleUitls();
        connection = databaseUtils.getConnection();
        connection.connect();
        command = databaseUtils.getCommand();
        command.command();
    }
}

//模拟数据库

//规范设计
interface IConnection {
    void connect();
}
interface ICommand {
    void command();
}
interface DatabaseUtils {
    IConnection getConnection();
    ICommand getCommand();
}

//具体实现
class MysqlConnection implements IConnection {

    public void connect() {
        System.out.println("Mysql connected.");
    }
}
class MysqlCommand implements ICommand {
    public void command() {
        System.out.println("Mysql command.");
    }
}
class MysqlUitls implements DatabaseUtils {

    public IConnection getConnection() {
        return new MysqlConnection();
    }

    public ICommand getCommand() {
        return new MysqlCommand();
    }
}


class OracleConnection implements IConnection {

    public void connect() {
        System.out.println("Oracle connected.");
    }
}
class OracleCommand implements ICommand {
    public void command() {
        System.out.println("Oracle command.");
    }
}
class OracleUitls implements DatabaseUtils {

    public IConnection getConnection() {
        return new OracleConnection();
    }

    public ICommand getCommand() {
        return new OracleCommand();
    }
}
```

提供一个创建一系列相关或互相依赖对象的接口，而无需指定他们具体的类。

由一些工厂方法模式组合而成。

**应用场景：**

程序需要处理不同系列的相关产品，但是不希望它依赖这些产品的具体类时，可以使用抽象工厂。

**优点：**

1. 可以确信从工厂得到的产品是彼此兼容的
2. 可以避免具体产品和客户端代码之间的紧密结合
3. 符合单一职责原则
4. 符合开闭原则

## 建造者模式

![image-20210113205223152](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210113205223152.png)

```java
public class BuilderTest {
    public static void main(String[] args) {
        Product product = new Product.Builder().part1("part1").part2("part2").builder();
        System.out.println(product);
    }
}

class Product {
    private final String part1;
    private final String part2;
    private final String part3;
    private final String part4;

    public Product(String part1, String part2, String part3, String part4) {
        this.part1 = part1;
        this.part2 = part2;
        this.part3 = part3;
        this.part4 = part4;
    }

    @Override
    public String toString() {
        return "Product{" +
                "part1='" + part1 + '\'' +
                ", part2='" + part2 + '\'' +
                ", part3='" + part3 + '\'' +
                ", part4='" + part4 + '\'' +
                '}';
    }

    public static class Builder {
        private String part1;
        private String part2;
        private String part3;
        private String part4;

        public Builder part1(String part1) {
            this.part1 = part1;
            return this;
        }
        public Builder part2(String part2) {
            this.part2 = part2;
            return this;
        }
        public Builder part3(String part3) {
            this.part3 = part3;
            return this;
        }
        public Builder part4(String part4) {
            this.part4 = part4;
            return this;
        }

        public Product builder() {
            return new Product(this.part1, this.part2, this.part3, this.part4);
        }
    }
}
```

**应用场景：**

1. 需要生成的对象具有复杂的内部结构
2. 需要生成的对象内部属性本身相互依赖
3. 与不可变对象配合使用

**优点：**

1. 建造者独立，易扩展
2. 便于控制细节风险



## 原型模式（Prototype）

![image-20210114195524307](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210114195524307.png)

```java
public class PrototypeTest {
    public static void main(String[] args) throws CloneNotSupportedException {
        BaseInfo baseInfo = new BaseInfo("chy");
        Product product = new Product("part1", "part2", "part3", "part4", baseInfo);

        Product clone = (Product) product.clone();
        System.out.println(product);
        System.out.println(clone);

    }
}


class BaseInfo implements Cloneable {
    private String name;

    public BaseInfo(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return super.hashCode() + " BaseInfo{" +
                "name='" + name + '\'' +
                '}';
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return ((BaseInfo) super.clone());
    }
}

class Product implements Cloneable {
    private String part1;
    private String part2;
    private String part3;
    private String part4;
    private BaseInfo baseInfo;

    public Product(String part1, String part2, String part3, String part4, BaseInfo baseInfo) {
        this.part1 = part1;
        this.part2 = part2;
        this.part3 = part3;
        this.part4 = part4;
        this.baseInfo = baseInfo;
    }

    public String getPart1() {
        return part1;
    }

    public void setPart1(String part1) {
        this.part1 = part1;
    }

    public String getPart2() {
        return part2;
    }

    public void setPart2(String part2) {
        this.part2 = part2;
    }

    public String getPart3() {
        return part3;
    }

    public void setPart3(String part3) {
        this.part3 = part3;
    }

    public String getPart4() {
        return part4;
    }

    public void setPart4(String part4) {
        this.part4 = part4;
    }

    public BaseInfo getBaseInfo() {
        return baseInfo;
    }

    public void setBaseInfo(BaseInfo baseInfo) {
        this.baseInfo = baseInfo;
    }

    @Override
    public String toString() {
        return super.hashCode() + " Product{" +
                "part1='" + part1 + '\'' +
                ", part2='" + part2 + '\'' +
                ", part3='" + part3 + '\'' +
                ", part4='" + part4 + '\'' +
                ", baseInfo=" + baseInfo +
                '}';
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Product clone = (Product) super.clone();
        BaseInfo clone1 = (BaseInfo) clone.baseInfo.clone();
        clone.setBaseInfo(clone1);
        return clone;
    }
}
```

通过拷贝原型实例创建新的对象。可以实现java中的`Cloneable`接口，实现clone方法来实现拷贝。需要注意浅拷贝和深拷贝，即需要考虑类属性中的类型，在进行拷贝时，不止需要调用自身父类的clone方法，还要对属性进行clone。也可以使用简单工厂模式返回原型拷贝对象，或者使用序列化机制实现深拷贝（不推荐，cpu密集型）。

**应用场景：**

当代码不应该依赖于需要复制的对象的具体类时，使用原型模式。

**优点：**

1. 可以不耦合具体类的情况下克隆对象
2. 避免重复的初始化代码
3. 更方便的构建复杂对象

## 享元模式（Flyweight）

![image-20210114203538750](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210114203538750.png)

```java
public class FlyweightTest {
    public static void main(String[] args) {
        TreeNode treeNode1 = new TreeNode(3, 4, TreeFactory.getTree("abc", "123"));
        TreeNode treeNode2 = new TreeNode(3, 4, TreeFactory.getTree("abc", "123"));

        TreeNode treeNode3 = new TreeNode(3, 4, TreeFactory.getTree("abc1", "123"));
        TreeNode treeNode4 = new TreeNode(3, 4, TreeFactory.getTree("abc1", "123"));
    }
}

class TreeNode {
    private int x;
    private int y;
    private Tree tree;

    public TreeNode(int x, int y, Tree abc) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public Tree getTree() {
        return tree;
    }

    public void setTree(Tree tree) {
        this.tree = tree;
    }

    @Override
    public String toString() {
        return "TreeNode{" +
                "x=" + x +
                ", y=" + y +
                ", tree=" + tree +
                '}';
    }
}
class Tree {
    private final String name;
    private final String data;

    public Tree(String name, String data) {
        this.name = name;
        this.data = data;
        System.out.println("Tree " + name + " create!");
    }

    public String getName() {
        return name;
    }

    public String getData() {
        return data;
    }
}

class TreeFactory {
    private static Map<String, Tree> map = new ConcurrentHashMap<> ();
    public static Tree getTree(String name, String data) {
        if (map.containsKey(name)) {
            return map.get(name);
        }
        Tree tree = new Tree(name, data);
        map.put(name, tree);
        return tree;
    }
}
```

共享大量细粒度的对象，对对象重复使用（对象只创建一次，后面重复使用），节省资源，注意线程安全。

**优点：**

如果系统有大量类似的对象，可以节省大量的内存和cpu资源

## 门面模式（Facade）

![image-20210115195417616](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210115195417616.png)

为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

**应用场景：**

1. 当需要使用复杂子系统的有限但直接的接口时
2. 当想要将子系统组织成层时

**优点：**

简化客户端调用。



## 适配器模式（Adapter）

![image-20210115200917931](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210115200917931.png)

将一个类的接口转换成客户端的另一个接口，适配器模式使得原本由于接口不**兼容**不能一起工作的那些类可以一起工作。

```java
//对象适配器模式
public class AdapterTestV1 {
    public static void main(String[] args) {
        Adaptee adaptee = new Adaptee();
        Target target = new Adapter(adaptee);
        target.output5v();
    }
}

class Adaptee {
    public int output() {
        return 200;
    }
}

interface Target {
    int output5v();
}

//Object Adapter
class Adapter implements Target {

    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public int output5v() {
        int i = adaptee.output();
        //...
        System.out.println(String.format("Original v : %d , output v : %d .", i, 5));
        return 5;
    }
}
```

```java
//类适配器模式
public class ApaterTest {
    public static void main(String[] args) {
        Adapter adapter = new Adapter();
        adapter.output5v();
    }
}

class Adaptee {
    public int output() {
        return 200;
    }
}

interface Target {
    int output5v();
}

//Class Adapter
class Adapter extends Adaptee implements Target {

    @Override
    public int output5v() {
        int i = output();
        //...
        System.out.println(String.format("Original v : %d , output v : %d .", i, 5));
        return 5;
    }
}
```

对象适配器模式是使用组合的模式来完成的，类适配器模式使用继承的方式来完成的。

类适配器模式可以访问父类的方法，不符合最少知道原则。



## 装饰器模式（Decorator）

![image-20210115204145120](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210115204145120.png)

```java
public class DecoratorTest {
    public static void main(String[] args) {
        Component component = new ConcreteComponent();
        component.operation();
        Component decorator1 = new Decorator1(component);
        decorator1.operation();
        Component decorator2 = new Decorator2(component);
        decorator2.operation();
    }
}

interface Component {
    void operation();
}

class ConcreteComponent implements Component {

    @Override
    public void operation() {
        System.out.println("拍照。");
    }
}

class Decorator1 implements Component {

    Component component;

    public Decorator1(Component component) {
        this.component = component;
    }

    @Override
    public void operation() {
        System.out.println("美颜。");
        component.operation();
    }
}
class Decorator2 implements Component {

    Component component;

    public Decorator2(Component component) {
        this.component = component;
    }

    @Override
    public void operation() {
        System.out.println("滤镜。");
        component.operation();
    }
}
```

**应用场景：**

扩展一个类的功能，给一个类添加附加职责

**优点：**

1. 不改变原有对象的情况下给一个对象扩展功能
2. 使用不同的组合可以实现不同的效果
3. 符合开闭原则





## 策略模式（Strategy）

![image-20210117180926299](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210117180926299.png)

一个类的行为或其算法可以在运行时更改。

**主要解决：**在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

**何时使用：**一个系统有许多许多类，而区分它们的只是他们直接的行为。

**如何解决：**将这些算法封装成一个一个的类，任意地替换。

**关键代码：**实现同一个接口。



## 模板方法模式（Template）

![image-20210117211058706](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210117211058706.png)

定义一个操作的算法骨架，将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构可重定义该算法的某些特定步骤。

**主要解决：**一些方法通用，却在每一个子类都重新写了这一方法。

**何时使用：**有一些通用的方法。

**如何解决：**将这些通用算法抽象出来。

**关键代码：**在抽象类实现，其他步骤在子类实现。

```java
public class TemplateTest {
    public static void main(String[] args) {
        Template template = new ConcreteClass();
        template.operation();
    }
}

abstract class Template {
    public void operation() {
        //prepare
        System.out.println("pre ...");
        System.out.println("step1 ...");
        System.out.println("step2 ...");

        templateMethod();
    }
    abstract protected void templateMethod();
}

class ConcreteClass extends Template {

    @Override
    protected void templateMethod() {
        System.out.println("Subclass method");
    }
}
```



## 观察者模式（Observer）

![image-20210120170059242](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210120170059242.png)

```java
public class ObserverTest {
    public static void main(String[] args) {
        Subject subject = new Subject();
        Observer task1 = new Task1();
        Observer task2 = new Task2();
        subject.addObserver(task1);
        subject.addObserver(task2);
        subject.notifyObserver("1111");
    }
}

class Subject {
    private List<Observer> container = new ArrayList<>();

    public void addObserver(Observer observer) {
        container.add(observer);
    }
    public void removeObserver(Observer observer) {
        container.remove(observer);
    }
    public void notifyObserver(Object object) {
        for (Observer observer: container) {
            observer.update(object);
        }
    }
}

interface Observer {
    void update(Object object);
}


class Task1 implements Observer {

    @Override
    public void update(Object object) {
        System.out.println(" Task1 received: " + object);
    }
}

class Task2 implements Observer {

    @Override
    public void update(Object object) {
        System.out.println(" Task2 received: " + object);
    }
}
```

**应用场景：**

当更改一个对象的状态可能需要更改其他对象，并且实际的对象集事先未知或动态更改时。

**优点：**

1. 符合开闭原则
2. 可以在运行时建立对象之间的关系



## 责任链模式（Chain of Responsibility）

![image-20210121131845096](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210121131845096.png)

![image-20210121132433519](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210121132433519.png)

```java
public class ChainOfResponsibilityTest {
    public static void main(String[] args) {
        Request request = new Request.RequestBuilder().loggedOn(true).frequentOk(true).build();
        Handler handler = new RequestFrequentHandler(new LoggedOnHandler(null));
        System.out.println(handler.process(request));
    }
}

class Request {
    private boolean loggedOn;
    private boolean frequentOk;
    private boolean isPermits;
    private boolean containsSensitiveWords;
    private String requestBody;

    public Request(boolean loggedOn, boolean frequentOk, boolean isPermits, boolean containsSensitiveWords) {
        this.loggedOn = loggedOn;
        this.frequentOk = frequentOk;
        this.isPermits = isPermits;
        this.containsSensitiveWords = containsSensitiveWords;
    }

    static class RequestBuilder {
        private boolean loggedOn;
        private boolean frequentOk;
        private boolean isPermits;
        private boolean containsSensitiveWords;

        RequestBuilder loggedOn(boolean loggedOn) {
            this.loggedOn = loggedOn;
            return this;
        }
        RequestBuilder frequentOk(boolean frequentOk) {
            this.frequentOk = frequentOk;
            return this;
        }
        RequestBuilder isPermits(boolean isPermits) {
            this.isPermits = isPermits;
            return this;
        }
        RequestBuilder containsSensitiveWords(boolean containsSensitiveWords) {
            this.containsSensitiveWords = containsSensitiveWords;
            return this;
        }
        public Request build() {
            Request request = new Request(this.loggedOn, this.frequentOk, this.isPermits, this.containsSensitiveWords);
            return request;
        }
    }

    public boolean isLoggedOn() {
        return loggedOn;
    }

    public boolean isFrequentOk() {
        return frequentOk;
    }

    public boolean isPermits() {
        return isPermits;
    }
    public boolean isContainsSensitiveWords() {
        return containsSensitiveWords;
    }
}

abstract class Handler {
    private Handler next;

    public Handler(Handler next) {
        this.next = next;
    }

    public Handler getNext() {
        return next;
    }

    public void setNext(Handler next) {
        this.next = next;
    }

    abstract public boolean process(Request request);
}

class LoggedOnHandler extends Handler {

    public LoggedOnHandler(Handler next) {
        super(next);
    }

    @Override
    public boolean process(Request request) {
        System.out.println("登录控制。");
        if (request.isLoggedOn()) {
            Handler handler = getNext();
            if (null==handler) {
                return true;
            }
            if (!handler.process(request)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }
}

class RequestFrequentHandler extends Handler {

    public RequestFrequentHandler(Handler next) {
        super(next);
    }

    @Override
    public boolean process(Request request) {
        System.out.println("访问频率控制。");
        if (request.isFrequentOk()) {
            Handler handler = getNext();
            if (null==handler) {
                return true;
            }
            if (!handler.process(request)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }
}

class PermitsHandler extends Handler {

    public PermitsHandler(Handler next) {
        super(next);
    }

    @Override
    public boolean process(Request request) {
        System.out.println("权限控制。");
        if (request.isPermits()) {
            Handler handler = getNext();
            if (null==handler) {
                return true;
            }
            if (!handler.process(request)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }
}

class ContainsSensitiveHandler extends Handler {

    public ContainsSensitiveHandler(Handler next) {
        super(next);
    }

    @Override
    public boolean process(Request request) {
        System.out.println("敏感词控制。");
        if (request.isContainsSensitiveWords()) {
            Handler handler = getNext();
            if (null==handler) {
                return true;
            }
            if (!handler.process(request)) {
                return false;
            } else {
                return true;
            }
        }
        return false;
    }
}
```

**应用场景：**

一个请求的处理需要多个对象当中的一个或几个协作处理

**优点：**

1. 请求的发送者和接收者解耦
2. 可以控制执行顺序
3. 符合开闭原则和单一职责原则





## 代理模式

![image-20210121191128852](/../../../../../AppData/Roaming/Typora/typora-user-images/image-20210121191128852.png)

### 静态代理

```java
public class StaticProxyTest {
    public static void main(String[] args) {
        UserDao target = new UserDao();
        UserDaoProxy userDaoProxy = new UserDaoProxy(target);
        userDaoProxy.save();
    }
}

interface IUserDao {
    public void save();
}

class UserDao implements IUserDao {

    @Override
    public void save() {
        System.out.println("保存数据。");
    }
}

class UserDaoProxy implements  IUserDao {

    private IUserDao target;

    public UserDaoProxy(IUserDao target) {
        this.target = target;
    }

    @Override
    public void save() {
        System.out.println("开始事务。");
        target.save();
        System.out.println("结束事务。");
    }
}
```

共同实现一个接口，以组合形式实现。

### 动态代理

生成一个动态代理的对象，然后这个对象会继承Proxy，并且实现了被代理对象的接口，然后这个代理对象的夫类里面会根据传入的invocationHandler初始化一个handle，然后调用代理对象的方法时，在那个动态代理对象的代码中，就是调用了父类的invocationHandler的invoke方法，然后这个invoke方法调用的就是invocation对象的方法，里面有一个proceed方法，就是利用反射来调用被代理对象的方法的

使用JDK中生成代理对象。关键就是这两个东西：Proxy、InvocationHandler。

1. 定义一个接口

   ```java
   public interface IUserDao {
       public void save();
   }
   ```

2. 被代理对象，实现这个接口

   ```java
   public class UserDao implements IUserDao {
       @Override
       public void save() {
           System.out.println("保存数据。");
       }
   }
   ```

3. 代理对象，实现`InvocationHandler`接口

   ```java
   public class UserDaoProxy implements InvocationHandler {
   
       private Object obj;
   
       public UserDaoProxy() {
       }
   
       public UserDaoProxy(Object obj) {
           this.obj = obj;
       }
   
       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           System.out.println("开始事务");
           method.invoke(obj, args);
           System.out.println("结束事务");
           return null;
       }
   }
   ```

4. 测试类

   ```java
   public class DynamicProxyTest {
       public static void main(String[] args) {
           IUserDao userDao = new UserDao();
   
           InvocationHandler handler = new UserDaoProxy(userDao);
   
           IUserDao proxy = (IUserDao) Proxy.newProxyInstance(userDao.getClass().getClassLoader(), userDao.getClass().getInterfaces(), handler);
   
           proxy.save();
       }
   }
   ```



### Cglib代理

上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理

Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.

- JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.
- Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)
- Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.



1. 定义被代理对象类

   ```java
   public class UserDao {
       public void save() {
           System.out.println("保存数据");
       }
   }
   ```

2. 定义代理对象类，实现`MethodInterceptor`接口

   ```java
   public class UserDaoProxy implements MethodInterceptor {
   
       private Object obj;
   
       public UserDaoProxy(Object obj) {
           this.obj = obj;
       }
   
       public Object getProxyInstance() {
           //1. 创建一个工具类
           Enhancer enhancer = new Enhancer();
           //2. 设置父类
           enhancer.setSuperclass(obj.getClass());
           //3. 设置回调函数
           enhancer.setCallback(this);
           //4. 创建子类对象，即代理对象
           return enhancer.create();
       }
   
   
       public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
           System.out.println("开始事务");
           method.invoke(obj, objects);
           System.out.println("结束事务");
           return null;
       }
   }
   ```

3. 测试类

   ```java
   public class GclibProxyTest {
       public static void main(String[] args) {
           UserDao target = new UserDao();
           UserDao proxy = (UserDao) new UserDaoProxy(target).getProxyInstance();
           proxy.save();
       }
   }
   ```

   













## 单例模式和享元模式的区别

享元模式可以再次创建对象 也可以取缓存对象

单例模式则是严格控制单个进程中只有一个实例对象

享元模式可以通过自己实现对外部的单例 也可以在需要的使用创建更多的对象

单例模式是自身控制 需要增加不属于该对象本身的逻辑

 

两者都可以实现节省对象创建的时间 ThreadPool 线程池 与数据库连接池 都有使用享元模式

单例模式和享元模式都是为了避免重复创建对象，但是其本质是不一样的：

1. 其实现方式不一样，单例是一个类只有一个唯一的实例，而享元可以有多个实例，只是通过一个共享容器来存储不同的对象。
2. 其使用场景不一样，单例是强调减少实例化提升性能，因此一般用于一些需要频繁创建和销毁实例化对象或创建和销毁实例化对象非常消耗资源的类中，如连接池、线程池。而享元则是强调共享相同对象或对象属性，节约内存使用空间。



## 装饰器模式和代理模式的区别

装饰者（decorator）和被装饰者（decoratee）都实现同一个 接口。对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。此外，不论我们使用哪一个模式，都可以很容易地在真实对象的方法前面或者后面加上自定义的方法。

​    然而，实际上，在装饰器模式和代理模式之间还是有很多差别的。**装饰模式主要是强调对类中代码的拓展，而代理模式则偏向于委托类的访问限制**。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。

对装饰器模式来说，装饰者（decorator）和被装饰者（decoratee）都实现同一个 接口。对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。他们之间的边界确实比较模糊，两者都是对类的方法进行扩展，具体区别如下：

1、装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你还是你，只不过能力更强了而已；代理模式强调要让别人帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。

2、装饰模式是以对客户端透明的方式扩展对象的功能，是继承方案的一个替代方案；代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用；

3、装饰模式是为装饰的对象增强功能；而代理模式对代理的对象施加控制，但不对对象本身的功能进行增强；

## 为什么推荐多用组合、少用继承

### 继承的弊端：

有这么一个情况：

> 你想要创建一个只有嘴巴的机器人类，并且这个机器人类只有一个行为：嘴巴吃东西。
>  你发现动物这个类有嘴巴，并且会吃东西，好，这就方便了，机器人类直接继承动物类。继承完毕，机器人有嘴巴了，但是嘴巴不仅会吃东西，还会说话了。你本身并不需要它会说话呀。这就是继承带来的坏处，带来了并不需要的属性或者行为方法。

> 这时候你又想，没事，想办法不让外界使用到这些多余的方法不就行了嘛。这时候两个办法：
>  方法1、把多余的行为方法都覆写一遍，改成你想透出给外界的方法。
>  方法2、换一个类继承。

上面两个方法看起来是不是都很变态，第一个方法你要覆写的方法可能会很多很多，多到你自己都搞不清楚了。第二个方法一样可能会继承到很多并不需要的属性或者行为方法。好，这个问题先告诉你可以用组合来解决，再来看另一个问题：
 比如你不仅想让机器人用嘴吃东西，还想它会做瑜伽。这时候怎么办，继承只能单继承呀。
 回头来看组合。

### 组合的优点：

> 组合的意思就是把你需要的东西组合在一个类里面，这个类并不需要继承任何父类，也可以提供想要的行为方法。

> 比如说上面的例子，我们可以创建一个机器人类，内部有一个动物对象，机器人类对外透出一个吃东西的方法，内部调用动物对象的嘴巴吃东西。这个时候从外部来看，嘴巴只会吃东西了，而不会说话。这个时候对于动物类来说模式就是组合，而不是继承。并且如果你想让机器人会做瑜伽，可以再内部创建一个会做瑜伽的类的对象，调用做瑜伽方法，或者实现一个做瑜伽的接口，实现接口的做瑜伽方法。

这样就可以避免单继承，而无限扩展。并且可以做到不用关心无用的方法。

